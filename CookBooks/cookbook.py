МНОЖЕСТВА
 intersection() #Метод используется для поиска пересечений в нескольких множествах;
    х={'творог', 'яйца', 'сахар', 'соль', 'мука', 'ванилин'}
    y={'творог', 'яйца', 'сахар', 'соль', 'манная крупа'}
    х.intersection(y)
    {'творог',  'соль', 'сахар', 'яйца'} # В результате мы получили новый сет, который состоит из элементов, присутствующих в обоих множествах.
difference() #Метод используется для поиска разности двух множеств.
    х={'творог', 'яйца', 'сахар', 'соль', 'мука', 'ванилин'}
    y={'творог', 'яйца', 'сахар', 'соль', 'манная крупа'}
    х.difference(y)
    {'мука', 'ванилин'} # В результате мы получили новый сет, который содержит элементы, уникальные для множества х. Аналогичную операцию можно проделать и для множества y.
х.symmetric_difference(y)
    х = {'творог', 'яйца', 'сахар', 'соль', 'мука', 'ванилин'}
    y = {'творог', 'яйца', 'сахар', 'соль', 'манная крупа'}
    х.symmetric_difference(y)
    {'ванилин', 'манная крупа', 'мука'} # в результате мы получили новое множество, которое содержит элементы, присутствующие только в одном из множеств, х или y
х.issubset(y)
    х = {'творог', 'яйца', 'сахар', 'соль'}
    y = {'творог', 'яйца', 'сахар', 'соль', 'мука', 'ванилин'}
    х.issubset(y)
    True # мы ожидаемо получили ответ True, это означает, что все элементы списка х входят в множество y
y.issubset(x)  
    х = {'творог', 'яйца', 'сахар', 'соль'}
    y = {'творог', 'яйца', 'сахар', 'соль', 'мука', 'ванилин'}
    y.issubset(x)
    False # множество y шире, чем множество х, поэтому в результате применения метода y.issubset(х) мы получили отрицательный результат
х.add()   
    х={'творог', 'яйца', 'сахар', 'соль', 'мука'}
    х.add('масло')
    print(х)
    {'сахар', 'соль', 'мука', 'творог', 'яйца', 'масло'}
х.remove()    
    х={'творог', 'яйца', 'сахар', 'соль', 'мука', 'масло'}
    х.remove('масло')
    print(х)
    {'сахар', 'соль', 'мука', 'творог', 'яйца'}  
x=х.union(у)
    х = {'творог', 'яйца'}
    у = {'сахар', 'соль', 'мука'}
    х.union(у)
    {'мука', 'сахар', 'соль', 'творог', 'яйца'}    
х.update(у) #он позволяет расширить исходное множество не только за счет другого множества, но за счет списков и других типов данных. Еще одна его особенность заключается в том, что он перезаписывает исходное множества, поэтому нам не понадобится осуществлять присваивание, но необходимо будет использовать print(), чтобы вывести обновленное множество.    
    х = {'творог', 'яйца'}
    у = ['сахар', 'соль', 'мука']
    х.update(у)
    print(х)
    {'мука', 'сахар', 'соль', 'творог', 'яйца'}

СЛОВАРИ
countries = {'Великобритания': 'Лондон', 'Россия': 'Москва', 'Марокко': 'Рабат', 'Монголия': 'Улан-Батор', 'Эстония': 'Таллин'}

countries ['Франция'] = 'Париж' #add пара ключ:значение будет добавлена в конец словаря
countries.update({'Франция' : 'Париж'})#add пара ключ:значение будет добавлена в конец словаря

del countries ['Франция']
Метод pop() #безопасный метод удаления элемента из словаря
countries.pop('Франция', -1)
Париж # код удалил пару ключ-значение и вернул значение 'Париж'
countries.pop('Испания', -1)
-1 # так как наш словарь не содержит элемента с ключом 'Испания', программа вывела значение по умолчанию -1

'Эстония' in countries
True # Эстония действительно есть в списке. Обратите внимание, что в данном случае нам не понадобилось писать print: код показывает результат проверки вхождения в любом случае.
'Таллин' in countries
False # программа выдала отрицательный результат, так как, несмотря на то, что 'Таллин' входит в словарь, это значение, а не ключ

Метод get() #возвращает значение по ключу. Если в словаре не нашлось элемента с таким ключом, то возвращается значение None. Никаких ошибок при этом не возникает.
countries.get('Испания', 'Пока в словаре нет столицы для этой страны')
'Пока в словаре нет столицы для этой страны' # если бы мы не использовали метод get(), то программа остановилась бы из-за ошибки, но с  этим методом мы получаем текст, который сами указали

countries.keys()
dict_keys(['Великобритания', 'Россия', 'Марокко', 'Монголия', 'Эстония', 'Франция']) # с помощью этого метода мы узнали, сведения о каких странах хранятся в словаре.
list(countries.keys())[0]
>> Великобритания

countries.values()
dict_values(['Лондон', 'Москва', 'Рабат', 'Улан-Батор', 'Таллин', 'Париж']) # с помощью этого метода мы узнали, сведения о каких мировых столицах хранятся в  словаре.
list(countries.values())[-1]
>> Таллин

countries.items()
dict_items([('Великобритания', 'Лондон'), ('Россия', 'Москва'), ('Марокко', 'Рабат'), ('Монголия', 'Улан-Батор'), ('Эстония', 'Таллин'), ('Франция', 'Париж')]) # код вывел список всех ключей и значений, заключив каждую из пар ключ:значение в круглые скобки.

for key in countries:
    print(key, countries[key]) # countries[key] используется для доступа к  значению, связанному с текущим ключом

Великобритания Лондон
Россия Москва
Марокко Рабат
Монголия Улан-Батор
Эстония Таллин

for key, value in countries.items(): # обратите внимание, что в цикл мы передали два значения key и value. Они соответственно принимают значения из метода items, где key — это только ключи, value — только значения.
    print(key, value)

Великобритания Лондон
Россия Москва
Марокко Рабат
Монголия Улан-Батор
Эстония Таллин


СПИСКИ
x.append(y) #для данного метода не нужна операция присваивания 
    x=[1,2,3]
    y=[4,5]
    x.append(y)
    print(x)
    [1, 2, 3, [4,5]] #append вставил список целиком
a.extend(b)
    a = [1, 2]
    b=[3,4]
    a.extend(b)
    print(a)
    [1, 2, 3, 4] # extend работает только со списками, вставляет значения из списка 
a.insert(i,x)  где i — индекс, который должен иметь элемент в списке.
    a = [1, 2]
    a.insert(0, 3)
    print(a)
    [3, 1, 2]
b=a.pop(i) #по умолчанию последнее значение
    a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    b = a.pop(0)
    print(a)
    print(b)
    [2, 3, 4, 5, 6, 7, 8, 9, 10]
    1
a.clear()
    a = [1, 2, 3, 4, 5]
    print(a)
    a.clear()
    print(a)
    []
sorted(cost,reverse=True)   #По умолчанию reverse равен False и сортирует список по возрастанию.
    cost = [3899, 4599,29999,5999,89999,103999]  
    name=['Трекер','Криптокошелек','Умная колонка','Умный чемодан','Умные шахматы','Смарт-очки']             
    print(sorted(cost,reverse=True))       
    print(sorted(name))                    
    .                                     
    [103999, 89999, 29999, 5999, 4599, 3899]  
    ['Криптокошелек', 'Смарт-очки', 'Трекер', 'Умная колонка', 'Умные шахматы', 'Умный чемодан']
a = s.split()   #Если разделитель не указан, по умолчанию используется пробел.
    s = 'Введите предложение с клавиатуры'    
    a = s.split()
    print(a)
    ['Введите', 'предложение', 'с', 'клавиатуры']  
' '.join(a)      
    a = ['наше', 'первое', 'предложение']
    s = ' '.join(a)
    print(s)               
    наше первое предложение 

 
my_list = [1, 2, 3] — пример создания списка;
my_set = {1, 2, 3} — пример создания множества;
СЛОВАРЬ (DICT):
dictionary = {'planet':['Меркурий', 'Венера', 'Земля'],'distance (million km)':[58, 108, 150], }

set() — функция преобразования списка во множество;
list () — функция преобразования множества в список;

import math as m
    math.floor(x)
    округляет число вниз
    math.ceil(x)
    округляет число вверх
    math.fabs(x)
    модуль (абсолютная величина)
    math.sqrt(x)
    квадратный корень
    math.log(x, b)
    натуральный логарифм, при вызове в виде log(x, b) возвращает логарифм по основанию b

if not (x == y): # Проверяем, что значения x и y не равны друг другу.
    print(‘числа не равны друг другу’)
    if x % 2 == 0:
        print(‘x — четное число’)
    else:
        print(‘x — нечетное число’)
elif х == 0:
    print('х равно нулю')
elif х > 0:
    print('х — положительное число’)
else:
    result = 0
print(result)

while x >= 0: # проверяем, что х больше или равен 0
    x = int(input('Введите любое число '))
    
break — прерывает работу всего цикла и выходит из него. Break полезен, когда мы достигли желаемого значения или получили параметры, не подходящие для нашей программы;
continue — останавливает работу только одного витка цикла и начинает его выполнение заново. С помощью continue мы можем пропустить значения, с которыми мы не хотим выполнять преобразование, но при этом не завершать работу цикла полностью.

for i in (1,2,3,4,5):
       print(i):
       
range(начало, конец не включая, шаг)

for i in range(1, 5, 1):
    print(i)
    
списочное выражение (list comprehension).
    n1=[1,2,3]
    n = [str(n1[i]) for i in range(3)]
    n
    ['1', '2'] 

map(function, iterable, ...)
    x = map(plus, [1, 2], [3, 4], [5, 6])
    list(x)
    # [9, 12]

    x = [1, 2, 3]
    y = [4, 5, 6, 7]
    list(map(pow, x, y))
    # [1, 32, 729]

    >>> import re
    >>> def clean(word):
    ...        return re.sub(r"[`!?.:;,'\"()-]", "", word.strip())

    >>> text = ""С помощью цикла `for .. in:` программе 
    необходимо хранить в памяти системы весь (список)! ""
    >>> word = text.split()
    >>> word = map(clean, word)
    >>> text = ' '.join(word)
    >>> text
    # 'С помощью цикла for  in программе необходимо 
    # хранить в памяти системы весь список

text=text.split(' ')

слайсы только по str
s = 'Привет!'
print(s[0:6:2])
Пие
s[58:-13]
s[:43]

s='1o1'
s.isdigit() 
False

s = 'Строка, в которой мы ищем символы'
s.find('й') 
16 # в строке s первое вхождение символа “й” находится на 16 позиции

s = 'Строка, в которой мы ищем символы'
print(s.count('о'))
1 # Символ ‘о’ встретился в нашей строке 1 раз, метод чувствителен к регистру

print(s.lower())
print(s.upper())
строка, в которой мы ищем символы
СТРОКА, В КОТОРОЙ МЫ ИЩЕМ СИМВОЛЫ

s ='Евгений_Петров'
s=s.replace('_', ' ') #замена всех символов
print(s)
Евгений Петров

import re #Чтобы использовать регулярные выражения в коде

import re

re.findall(r'\d+', 'Оплата за товары и услуги в ООО «Futuronic» по заказу No. 9876543 от 07.09.2023')
['9876543', '07', '09', '2023'] # В результате мы получили все последовательности цифр в виде списка. Обратите внимание, что из-за использование точки в дате дата, месяц и год выводятся отдельными элементами списка.     
r'\d+'
d отвечает за целые числа от 0 до 9,
+  означает что они могут встретиться 1 или более раз подряд без разделителей;

 r’[а-яА-яёЁ]+’ 
 говорит о том, что нам необходимо оставить символы между а и я. Причем, чтобы учесть верхний и нижний регистр, нужно сделать это дважды. Кроме этого, нужно помнить, что в классическом алфавите Python нет буквы ‘ё’, поэтому дополнительно нужно указать и ее.
 
 r‘[a-zA-Z]+’: # В результате мы получили все буквенные латинские значения без учета специальных символов.
 
 
 def my_check(a):
        if a.isdigit() == True: # для проверки
            if int(a) >= 0 and int(a) <= 50000:
                        return True
            else:
                return False
        else:
            return False
 
#вывести все значения из одного столбца 
    transactions = [[0, 312, 4232, 0, 1958, 3062, 1454], [0, 1, 5, 0, 3, 5, 4], [0, 3, 138, 0, 4, 14, 12]]
    for i in transactions:
        print(i[2])
    4232
    5
    138
    
#программа выведет все элементы нашей матрицы в столбик.
    transactions = [[0, 312, 4232, 0, 1958, 3062, 1454], [0, 1, 5, 0, 3, 5, 4], [0, 3, 138, 0, 4, 14, 12]]
    for row in transactions:
        for element in row:
            print(element)

    0
    312
    4232
    0
    1958
    …

#Ввод матрицы с клавиатуры
    print('Сколько строк будет в матрице?')
    n = int(input()) # ожидаем, что пользователь введет целое число, которое сохранится в переменной n
    print('Сколько элементов будет в строке?')
    m = int(input()) # ожидаем, что пользователь введет целое число, которое сохранится в переменной m

    second_matrix = [] # создаем пустой список, который будет использоваться для хранения элементов матрицы
    for i in range(n):
        row = []
        for i in range(m):
            print('Введите положительное целое число, не превышающее 1000') # ожидаем, что пользователь введет положительное целое число
            row.append(int(input())) # добавляем введенное число в текущую строку row
        second_matrix.append(row)

!pip3 list #Чтобы проверить, какие библиотеки предустановлены и не требуют скачивания
!pip3 install #название библиотеки — команда для установки библиотеки
!pip3 install --upgrade #название библиотеки — команда для обновления библиотеки
 
NumPy(Numerical Python extensions)
import numpy as np
np.array()
    expenses = [0, 312, 4232, 0, 1958, 3062, 1454]
    purchases = [0, 1, 5, 0, 3, 5, 4]
    cashback = [0, 3, 138, 0, 4, 14, 12]
    transactions = np.array([expenses, purchases, cashback])
    print(transactions)
    print(type(transactions))

    [[   0  312 4232    0 1958 3062 1454]
    [   0    1    5    0    3    5    4]
    [   0    3  138    0    4   14   12]]
    <class 'numpy.ndarray'>
    
x.ravel()
    transactions.ravel()
    array([   0,  312, 4232,    0, 1958, 3062, 1454,    0,    1,    5,    0,    3,    5,    4,    0,    3,  138,    0,    4,   14,   12]) # в результате работы кода мы получили одномерный массив со списком всех значений
    
np.zeros(y, x) — создает массив указанной формы, заполненный нулями;
np.ones(y, x) — создает массив указанной формы, заполненный единицами.
    C = np.ones((2, 3))
    print(C)
    [[1. 1. 1.]
    [1. 1. 1.]]
np.eye()
    D = np.eye(4)
    print(D)

    [[1. 0. 0. 0.]
    [0. 1. 0. 0.]
    [0. 0. 1. 0.]
    [0. 0. 0. 1.]]
    
    D = np.eye(4, 5)
    print(D)
    [[1. 0. 0. 0. 0.]
    [0. 1. 0. 0. 0.]
    [0. 0. 1. 0. 0.]
    [0. 0. 0. 1. 0.]]
np.nan  #NaN
    x = np.nan
x[0][:5]    #к матрице можно обратиться по слайсу — диапазону индексов. 
    transactions = np.array([[0, 312, 4232, 0, 1958, 3062, 1454], [0, 1, 5, 0, 3, 5, 4], [0, 3, 138, 0, 4, 14, 12]])
    print(transactions[0][:5]) # конечное значение не включается в диапазон
    print(sum(transactions[0][:5]))
    [   0  312 4232    0 1958]
    6502
x.transpose()    
x.T
    print(transactions.T) # метод T предоставляет более удобный и краткий способ для транспонирования матрицы
np.arange(начало, конец, шаг, тип данных) #позволяет работать с данными типа float.

np.random.rand(a,b) #матрица a на b со значениями [0,1)
np.random.randint()
    A = np.random.randint(low = 1, high = 10, size = (4, 4))#в интервале [1, 10)
    print(A)
    [[9 3 4 8]
    [8 5 4 7]
    [4 1 9 8]
    [2 6 6 9]]
    
np.min(A) = 1  — минимальное значение
np.max(A) = 9 — максимальное значение
np.mean(A) = 5.8125 — среднее значение
np.median(A) = 6.0 — медиана
np.sum(A) = 93 — сумма
#Если мы передадим в качестве второго параметра 0, то функция будет агрегировать данные по по столбцам, а если 1 — по строкам.
np.min(A, 0) = array([2, 1, 4, 7]) — минимальные значения по столбцам
np.max(A, 0) = array([9, 6, 9, 9]) — максимальные значения по столбцам
np.mean(A, 0) = array([5.75, 3.75, 5.75, 8.  ]) — средние значения по столбцам
np.median(A, 0) = array([6., 4., 5., 8.]) — медианные значения по столбцам
np.sum(A, 0) = array([23, 15, 23, 32]) — сумма значений по столбцам

np.min(A, 1) = array([3, 4, 1, 2]) — минимальные значения по строкам
np.max(A, 1) = array([9, 8, 9, 9]) — максимальные значения по строкам
np.mean(A, 1) = array([6.  , 6.  , 5.5 , 5.75]) — средние значения по строкам
np.median(A, 1) = array([6., 6., 6., 6.]) — медианные значения по строкам
np.sum(A, 1) = array([24, 24, 22, 23]) — сумма значений по строкам

Pandas
import pandas as pd

example_list = [1, 'Hello', True] # создаем список                                              example_series = pd.Series(example_list) # преобразуем список в series с помощью метода pd.Series()

# Чтобы посмотреть, что у нас получилось, используем print(example_series) или display(example_series)                  
print(example_series)         
0        1
1        Hello
2        True 

.iloc[2]
# Извлекаем элемент на позиции 2 (нумерация с нуля)
element = example_series.iloc[2] print(element)
True

pd.DataFrame
sales_list=[43,56,78,45] price_list=[340,500,299,100]
data_dict = {'sales':sales_list,'price':price_list}
df=pd.DataFrame(data_dict)
Или
df=pd.DataFrame(data={'sales':sales_list,'price':price_list})
Но в таком случае название словаря может быть только data, другие наименования не допускаются.

pd.read_csv
    df=pd.read_csv('2019.csv')
    # если бы у вас был Excel-файл, команда была бы очень похожей: df=pd.read_excel('2019.xlsx')

    df=pd.read_csv(‘C/Users/IvanPupkin/Downloads/archive/2019.csv ’)

# Сброс ограничений на количество выводимых рядов
pd.set_option('display.max_rows', None)

display(df.head()) # покажет первые 5 строк
display(df.tail(3)) # покажет последние 3 строки

display(df.shape)
display(df.shape[0]) display(df.shape[1])
(156, 9) # наша матрица имеет 156 строк и 9 столбцов 156 # мы можем по индексу обращаться к отдельному элементу размера: сейчас мы вывели число строк… 9 # … а сейчас число столбцов

display(df.info())
какие типы данные в ней лежат и есть ли пропущенные значения.

Чтобы вывести один столбец, укажем его название в квадратных скобках. Выведем только названия стран:
display(df[['Country or region']])

display(df[['Country or region']].head(3))
display(df[['Country or region']].tail(7))

display(df[['Country or region', 'Score']])

display(df['Country or region'][5])
display(df['Score'][100])

filtered_df = df[df['Country or region'] == 'Russia'] # после двойного равно указываем нужное значение

логическое ИЛИ |
    filtered3_df = df[(df['Country or region'] == 'Russia') | (df['Country or region'] == 'China')] 
    # обратите внимание, что каждое условие взято в круглые скобки  

isin()
    countries_to_select = ['Russia', 'China'] # создаем список из нужных нам критериев
    filtered3_df = df[df['Country or region'].isin(countries_to_select) 
    display(filtered3_df)# выводим только те строки, где есть элементы из списка

логическое И &
    filtered4_df = df[(df['Score'] >= 7) & (df['Social support'] <= 1.5)]
    display(filtered4_df)

df['Overall_rank_sum10']=df['Overall rank']+10 # мы создали новый столбец 'Overall_rank_sum10' и прибавили к каждой строке 10

df['GDP_Support']=df['GDP per capita']+df['Social support']

df['GDP_Support_round']=df['GDP_Support'].round(2)
display(df)

df.drop
df=df.drop(['Overall_rank_sum10','GDP_Support','GDP_Support_round'], axis=1) # перечислим через запятую все названия столбцов, которые мы хотим удалить и укажем, что мы хотим удалить элементы по вертикальной оси (axis = 1)
display(df)# проверим, что столбцы правда удалились

#по части стран сделать доп.столбцы
df=pd.read_csv('2018.csv')
co = ['Portugal','Spain', 'Italy','Greece']
df['Sc']=(7.632-df['Score']).round(1)
df['%GDP per capita']=(df['GDP per capita']/df['Score']*100).round(1)
df['%Social support']=(df['Social support']/df['Score']*100).round(1)
df4=df[df['Country or region'].isin(co)][['Overall rank','Country or region', 'Score','Sc','%GDP per capita','%Social support']]
display(df4)
OR
df2=df[['Overall rank','Country or region', 'Score','Sc','%GDP per capita','%Social support']]
df3=df2[df2['Country or region'].isin(co)]
display(df3)


df['Score'].min()
                        
df['Score'].max()
                        
df['Score'].median()
              
df['Score'].mean()

#Найдем среднее значение индекса счастья для стран из топ-10 рейтинга:
df[df['Overall rank'] <= 10]['Score'].mean()       
#Найдем среднее значение индекса счастья для Финляндии и Норвегии:
df[(df['Country or region'] == 'Finland') | (df['Country or region'] == 'Norway')]['Score'].mean()            

sort_values()
#По умолчанию используется сортировка по возрастанию True
display(df.sort_values(by=['Score'], ascending=True))      

display(df.sort_values('GDP per capita',ascending=False)['Country or region'][10])      

display(df.sort_values(by=['Social support','GDP per capita'],ascending=False))

display(df.sort_values(by=['Social support','GDP per capita'],ascending=[False, True]))      

# перезаписывать датафрейм    
df = df.sort_values(by=['Score'])
  
round(df[df['Country or region'].isin(countries_to_select)]['Score'].median(),2)
>>6.3    


query()
    filtered_df = df[df['Country or region'] == 'Russia']
    display(filtered_df) 
    -> 
    filtered_df2 = df.query('`Country or region`=="Russia"')
    display(filtered_df2)    
#название столбца выделено другим типом одинарных кавычек — ``; но они используются не всегда, а только когда в название столбца есть пробелы.

' `a a` == "a" '
`` если есть пробелы, чтобы query понял, что это один столбец
#Если название столбца состоит только из одного слова, а сам столбец содержит только числовые данные, то все выглядит гораздо проще. Выведем только те строки, в которых значение индекса счастья больше 7.5:
    filtered_df3 = df.query('Score==7.5') # нам потребовались только одинарные кавычки для обозначения всего условия
    display(filtered_df3)       

    filtered_df4=df.query('Score>7.5 or (`Social support`>1.4 and `GDP per capita`>1.4)') # следим за кавычками и порядком выполнения действий
    display(filtered_df4

#Чтобы «объяснить» query, что мы используем именно переменную, нам надо поставить специальный символ @ .    
@
    score_lvl=7.5                                                       filtered_df5=df.query('Score>score_lvl') #такой код приведет к ошибке

    score_lvl=7.5                                                   filtered_df5=df.query('Score>@score_lvl') #такой код успешно выполнится
    display(filtered_df4)

Группировка, уменьшение размерности
groupby()

product=['морковь','картофель','яблоки','груши']
product_cat=['овощи','овощи','фрукты','фрукты']price=[35, 50, 65, 70]
data_dict = {'продукт':product,'категория':product_cat,'цена':price} # собираем из списков словарь
df_ex=pd.DataFrame(data_dict) # преобразуем словарь в датафрейм
display(df_ex)  

grouped_ex = df_ex.groupby('категория') ['цена'] # в круглых скобках укажем параметр, по которому агрегируем (в данному случае хотим агрегировать данные по категориям); в квадратных - какие значения используем для расчетов (мы хотим поработать с ценами)

grouped_ex = df_ex.groupby('категория') ['цена'] 
display(grouped_ex.mean()) 
>>  категория
    овощи     42.5
    фрукты    67.5
    Name: цена, dtype: float64
    
OR

.agg('max')
(df_ex.groupby('категория'))['цена'].agg(‘mean’)# обратите внимание, что в данном случае mean нужно взять в кавычки    

df_new = df.groupby('col_n', as_index=False).agg({'col_1':'sum', 'col_2':'sum'})#Параметр as_index позволяет превратить результат в датафрейм, который можно использовать дальше, как обычный датафрейм
df_new = df.groupby(['col_n', 'col_m'], as_index=False).agg({'col_3':'sum', 'col_4':'sum'})

pivot_table().
values — какие данные мы будем агрегировать;
index — строки нашей будущей таблицы;
columns —  столбцы нашей будущей таблицы.
aggfunc — какую агрегирующую функцию используем (mean, max, min, sum, median).

data = {'Город': ['Москва', 'Москва', 'СПб', 'СПб', 'СПб'],
'Пол': ['М', 'Ж', 'М', 'М', 'Ж'],'Зарплата': [1000, 1200, 1100, 1050, 1300]} # если вы уже уверенно чувствуете себя в создании списков и преобразовании их в словарь, то можно делать это в один шаг
df_ex2 = pd.DataFrame(data)  
#Создадим сводную таблицу, которая покажет нам средние значения по городам:
pivot_table_1 = df_ex2.pivot_table(values='Зарплата', index='Город', aggfunc='mean')
display(pivot_table_1) 
>>	Город	Зарплата
    Москва	1100.0
    СПб	1150.0

pivot_table_3 = df_ex2.pivot_table(values='Зарплата', index='Город', columns='Пол', aggfunc='mean')
display(pivot_table_3)

>>  Пол	Ж	М
    Город		
    Москва	1200.0	1000.0
    СПб	1300.0	1075.0

df.pivot_table(['Score'], ['rank_group'], aggfunc='mean')).round(2) 
df.pivot_table(['Score'], ['rank_group'], aggfunc='mean')).round(2) 

#Выведем максимальное и минимальное зарплат по городам для каждого пола
pivot_table_3 = df_ex2.pivot_table(values='Зарплата', index='Город', columns='Пол', aggfunc=['max', 'min'])
>>      max	            min
Пол	    Ж	    М	    Ж	    М
Город				
Москва	1200	1000	1200	1000
СПб	    1300	1100	1300	1050

Преобразование строк

#Чтобы изменить тип данных
astype(type)
df['Overall rank']=df['Overall rank'].astype('float')

#Вспомним, какие методы и функции мы уже успели изучить за курс. Многие из них можно применять к строкам при работе с датафреймами Pandas.
int / str / float Перевод типов данных Не работает, но есть аналог astype()
math. floor / ceil / fabs / sqrt / log Математические операции Работают для строк
len Определение длины элементы Работает для строк
Обращение по индексам (слайсы) [] Создание слайсов, выделение фрагмента текста Работает для строк
isdigit Определение числа Работает для строк
find Поиск значения Работает для строк
count Подсчет вхождения доступен Работает для строк
lower / upper Изменение регистра Работает для строк
replace Замена символа Работает для строк регулярные выражения Регулярные выражения Могут применять к строкам
split / join Разделение и объединение фрагментов Работает для строк

df.columns  #вывод названия столбцов
    print(df.columns)
    Index(['Overall rank', 'Country or region', 'Score', 'GDP per capita',  
                       'Social support', 'Healthy life expectancy',
                       'Freedom to make life choices', 'Generosity'
                       'Perceptions of corruption', 'Country or region_lower',
                       'Country or region_lower_2'],
                     dtype='object')     
                     
# Приведем все названия столбцов к нижнему регистру с помощью str.lower()
df.columns=df.columns.str.lower()
df.columns
Index(['overall rank', 'healthy life expectancy', 'country or region', 'score','gdp per capita', 'social support', 'freedom to make life choices','generosity', 'perceptions of corruption'],dtype='object') #теперь все названия столбцов в нижнем регистр  

lambda
df['Country or region_lower']=df['Country or region'].apply(lambda x x.lower())

df['Int_Score']=df['Score'].astype('int')
df['Int_Score']=df['Score'].apply(lambda x:int(x))
df['Int_Score']=df['Score'].apply(lambda x:x).astype('int')

Практическое задание 3 к уроку 15 Часть 3 - Библиотека Pandas
import pandas as pd
df=pd.read_csv('2019.csv')
#df['Mix']=df['Country or region'].apply(lambda x: len(x.split(' ')))
#df['Mix2']=df['Mix'].apply(lambda x: 1 if x==1 else 2)
df['Mix']=df['Country or region'].apply(lambda x: 1 if len(x.split(' '))==1 else 2)
df.groupby('Mix', as_index=False).agg({'Score':'mean'})['Score'][0].round(2)



Matplotlib
